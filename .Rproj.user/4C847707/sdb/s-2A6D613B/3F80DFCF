{
    "contents" : "runDiffusion <- function(object = NULL, \n                         data = FELLA.DATA, \n                         approx = \"simulation\", \n                         niter = 1000, \n                         p.adjust = \"fdr\", \n                         BIMODAL = F) {\n  \n  # Checking the input\n  ##############################################################################\n  if (!is.FELLA.USER(object)) {\n    message(\"'object' is not a FELLA.USER object. Returning NULL...\")\n    return(invisible())\n  } \n  if (!is.FELLA.DATA(data)) {\n    message(\"'data' is not a FELLA.DATA object. Returning NULL...\")\n    return(invisible())\n  }\n  \n  if (data@keggdata@status != \"loaded\"){\n    message(\"'data' points to an empty FELLA.DATA object! Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (!is.character(approx)) {\n    message(\"'approx' must be a character: 'simulation' or 'normality'. Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (!(approx %in% c(\"simulation\", \"normality\"))) {\n    message(\"'approx' must be a character: 'simulation' or 'normality'. Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (!is.numeric(niter)) {\n    message(\"'niter' must be an integer between 100 and 1e5. Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (niter < 100 | niter > 1e5) {\n    message(\"'niter' must be an integer between 100 and 1e5. Returning original 'object'...\")\n    return(object)\n  }\n  ##############################################################################\n  \n  message(\"Running diffusion...\")\n  \n  # The metabolites in the input\n  comp.input <- getInput(object)\n  n.input <- length(comp.input)\n  \n  if (n.input == 0) {\n    message(\"Diffusion failed because there are no compounds in the input.\")\n    return(object)\n  }\n  \n  if (approx == \"simulation\") {\n    message(\"Estimating p-values by simulation.\")\n    \n    # The background\n    if (length(getBackground(object)) == 0) {\n      comp.background <- getCom(data, \"compound\")\n    } else {\n      comp.background <- getBackground(object)\n    }\n    \n    if (prod(dim(getMatrix(data, \"diffusion\"))) == 1) {\n      message(\"Diffusion matrix not loaded. Simulations will be slower...\")\n      \n      # Load the graph as undirected and its Laplacian\n      graph <- as.undirected(getGraph(data))\n      KI <- graph.laplacian(graph = graph, \n                            normalized = F, \n                            sparse = T)\n      # Connect pathways to boundary\n      diag(KI)[getCom(data, \"pathway\", \"id\")] <- diag(KI)[getCom(data, \"pathway\", \"id\")] + 1\n      \n      # Heat generation vector\n      generation <- numeric(dim(KI)[1])\n      names(generation) <- V(graph)$name\n      \n      # Current temperatures\n      generation[comp.input] <- 1\n      current.temp <- as.vector(solve(KI, generation))\n      generation[comp.input] <- 0\n      \n      # Null model\n      null.temp <- sapply(1:niter, function(dummy) {\n        if (dummy %% round(.1*niter) == 0) message(round(dummy*100/niter),\"%\")\n        \n        generation[sample(comp.background, n.input)] <- 1\n        as.vector(solve(KI, generation)) \n      })\n      \n      n.nodes <- length(current.temp)\n      pvalues <- sapply(1:n.nodes, function(row) {\n        ((1 - ecdf(null.temp[row, ])(current.temp[row]))*n.nodes + 1)/(n.nodes + 1)\n      })\n      names(pvalues) <- V(graph)$name\n      \n      \n\n    } else {\n      # Calculate current temperature\n      diffusion.matrix <- getMatrix(data, \"diffusion\")\n      \n      if (n.input == 1) {\n        current.temp <- diffusion.matrix[, comp.input]\n      }\n      else current.temp <- rowSums(diffusion.matrix[, comp.input])\n      \n\n      null.temp <- sapply(1:niter, function(dummy) {\n        if (dummy %% round(.1*niter) == 0) message(round(dummy*100/niter),\"%\")\n        \n        rowSums(diffusion.matrix[, sample(comp.background, n.input)])\n      })\n\n      n.nodes <- length(current.temp)\n      pvalues <- sapply(1:n.nodes, function(row) {\n        ((1 - ecdf(null.temp[row, ])(current.temp[row]))*n.nodes + 1)/(n.nodes + 1)\n      })\n      names(pvalues) <- rownames(diffusion.matrix)\n    }\n    \n    \n    \n  } else if (approx == \"normality\") {\n    message(\"Estimating p-values by normal tails.\")\n    \n    if (length(getBackground(object)) > 0 | BIMODAL) {\n      if (prod(dim(getMatrix(data, \"diffusion\"))) == 1) {\n        # Custom background, no matrix...\n        message(\"Diffusion matrix not loaded. Normality is not available yet for custom background.\")\n        return(object)\n      } else if (BIMODAL) {\n        # THIS ELSE IS THE ONLY BIMODAL THING\n        # you can safely delete it\n        background.matrix <- getMatrix(data, \"diffusion\")\n        idComp <- getCom(data, \"compound\")\n        \n        inputInfluence <- diag(background.matrix[idComp, idComp])\n#         browser()\n        \n        diag(background.matrix[idComp, idComp]) <- 0\n        \n        RowSums <- rowSums(background.matrix) \n        squaredRowSums <- apply(X = background.matrix, \n                                MARGIN = 1, \n                                FUN = function(row) sum(row*row))\n        \n        n.comp <- dim(background.matrix)[2]\n      } else {\n        # Custom background, matrix available\n        background.matrix <- getMatrix(data, \"diffusion\")[, getBackground(object)]\n        RowSums <- rowSums(background.matrix)\n        squaredRowSums <- apply(X = background.matrix, \n                                MARGIN = 1, \n                                FUN = function(row) sum(row*row))\n        \n        n.comp <- dim(background.matrix)[2]\n      }\n    } else {# Default background\n      n.comp <- length(getCom(data, \"compound\"))\n      \n      # RowSums\n      if (length(getSums(data, \"diffusion\", squared = F)) == 0) {\n        message(\"RowSums not available. The normal approximation cannot be done.\")\n        return(object)\n      } else {\n        RowSums <- getSums(data, \"diffusion\", squared = F)\n      }\n      \n      # Squared RowSums\n      if (length(getSums(data, \"diffusion\", squared = T)) == 0) {\n        message(\"squaredRowSums not available. The normal approximation cannot be done.\")\n        return(object)\n      } else {\n        squaredRowSums <- getSums(data, \"diffusion\", squared = T)\n      }\n    }\n    \n    # Compute current temperature\n    # Load the graph as undirected and its Laplacian\n    graph <- as.undirected(getGraph(data))\n    KI <- graph.laplacian(graph = graph, \n                          normalized = F, \n                          sparse = T)\n    # Connect pathways to boundary\n    diag(KI)[getCom(data, \"pathway\", \"id\")] <- diag(KI)[getCom(data, \"pathway\", \"id\")] + 1\n    \n    # Heat generation vector\n    generation <- numeric(dim(KI)[1])\n    names(generation) <- V(graph)$name\n    \n    # Current temperatures\n    generation[comp.input] <- 1\n    current.temp <- as.vector(solve(KI, generation))\n    \n    # p-values\n    temp.means <- RowSums*n.input/n.comp\n    temp.vars <- n.input*(n.comp - n.input)/(n.comp*(n.comp - 1))*(squaredRowSums \n                                                                   - (RowSums^2)/n.comp)\n    # ONLY THIS IS BIMODAL\n    if (BIMODAL){\n      # need to change the compounds\n      temp.means[idComp] <- RowSums[idComp]*(n.input)/(n.comp - 1) \n      temp.vars[idComp] <- (n.input )*(n.comp - 1 - n.input)/((n.comp - 1)*(n.comp - 2))*(squaredRowSums[idComp] \n                                                                                           - (RowSums[idComp]^2)/(n.comp - 1))\n#       browser()\n      # input:\n      theInput <- getInput(object)\n      temp.means[theInput] <- RowSums[theInput]*(n.input - 1)/(n.comp - 1) + inputInfluence[theInput]\n      temp.vars[theInput] <- (n.input - 1)*(n.comp - n.input)/((n.comp - 1)*(n.comp - 2))*(squaredRowSums[theInput] \n                                                                     - (RowSums[theInput]^2)/(n.comp - 1))\n      \n      \n    }\n    \n    \n    pvalues <- pnorm(current.temp, \n                     mean = temp.means, \n                     sd = sqrt(temp.vars), \n                     lower.tail = F)\n    names(pvalues) <- names(RowSums)\n#     browser()\n  } else {\n    stop(\"Invalid 'type' argument for heat diffusion. Please choose between 'simulation' and 'normality'\")\n  }\n\n  pvalues <- p.adjust(p = pvalues, method = p.adjust)\n\n  object@diffusion@pvalues <- pvalues\n  object@diffusion@approx <- approx\n  object@diffusion@niter <- niter\n\n  message(\"Done.\")\n  object@diffusion@valid <- T\n  return(object)\n}",
    "created" : 1441616310358.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2355155401",
    "id" : "3F80DFCF",
    "lastKnownWriteTime" : 1441621576,
    "path" : "~/Rstuffbro/FELLA/R/runDiffusion.R",
    "project_path" : "R/runDiffusion.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}