{
    "contents" : "\\documentclass{article}\n\\usepackage{booktabs}\n\\usepackage[T1]{fontenc}\n\\usepackage{caption}\n\\usepackage[sc]{mathpazo}\n\\usepackage{float}\n\\usepackage{graphicx}\n\\usepackage[textwidth=17cm,textheight=25cm]{geometry}\n\n\\setlength\\parindent{0pt}\n\n\\makeatletter\n\\def\\strippt{\\strip@pt}\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.\n\\usepackage{rotating}\n\\makeatother\n\n\\begin{document}\n\n% \\captionsetup{labelformat=empty}\n<<setup, include=FALSE, cache=FALSE>>=\noptions(replace.assign=TRUE,width=90)\n@\n\n\n\\title{FELLA v0.3 report}\n\\author{Sergio Picart-Armada \\qquad Alexandre Perera-Lluna \\\\ B2SLab at UPC}\n\\maketitle\n% \n% <<tableTest, results='asis', echo=FALSE>>=\n% test <- data.frame(x = 1:3, y = 1:3)\n% print(xtable(test, caption = '\\\\textbf{Test Table}', label = ''), \n%   caption.placement = getOption(\"xtable.caption.placement\", \"top\"), size = 'tiny')\n% @\n\n\\section{Metabolites enrichment using KEGG entries}\n\n\\subsection{Original idea}\n\nThe user of this tool has completed a case-control experiment. This gives him\ndata about the \\textbf{affected compounds} between control and case populations.\nGiven the \\textbf{KEGG id} of these compounds, FELLA performs an enrichment \nprocedure resulting in a straightforward interpretation.\n\nThe enrichment method heats up the affected compounds that live in the bottom of\na hierarchical structure. The final temperatures of every entry are compared to the null \nhypothesis, which states that the compounds are chosen at random. The relevant \nsubgraph is then extracted and analysed.\n\n\\subsection{Generalized enrichment}\n\nThe heating technique is strongly oriented to bottom-to-top heat flow. Thus, if \nthe user disposes of \\textbf{affected enzymes} instead of affected compounds and tries to heat them up, the result loses its clean interpretation. \n\nTo address this, FELLA attempts to solve the reverse problem: \\textit{given some affected enzymes, which compounds should be heated up so that the enzymes become \nsignificant again?} This procedure consists of two steps.\n\n\\subsubsection{Solution approximation}\n\nLet $q = q_1, \\ldots, q_{nc}$ be the heat generation vector, where $q_i = 1W$ \nif and only if compound $i$ is affected. Otherwise, $q_i = 0$.\nLet $e_1, \\ldots, e_{ne} \\in V(G)$ be the affected enzymes. Let $p_i = p_i(q)$ \nbe the p-value for node $i \\in V(G)$ given the generation $q$.\n\nWe define a cost function that should be minimized:\n\n$$f(q) = \\sum_{i \\in e_1, \\ldots, e_{ne}} p_i$$\n\nWe have to find an appropiate logical vector $q$, which is equivalent to determine\nwhether each compound should generate or not. Notice that adding too many compounds \nwill increase $f(q)$ as the significance will eventually drop for all the nodes.\n\nTo estimate this minimum, we have computed whether switching bit $q_k$ in $q$ \nimproves the cost function. \n\n$$\nJ_k f(q) = \\sum_{i \\in e_1, \\ldots, e_{ne}} \\Delta _k (p_i) = \\sum_{i \\in e_1, \\ldots, e_{ne}} p'_i(q'_k = ! q_k) - p_i(q)\n$$\n\n$$\nJ f(q) = (J_1 f(q), \\ldots, J_{nc} f(q) )\n$$\n\nIn order to find a first approximation, we start with $q = q^0 = 0$ and take a \npredefined number of steps, say $50$, to catch the most promising compounds. \nEach step can also remove a compound if this implies the largest descent for the \nobjective function. Having $q^{50}$, we refine this solution in the second part.\n\n\\subsubsection{Solution refinement}\n\nIn this step we want a more accurate input. We obtain that by penalizing even more \nthe objective function by the number of compounds that are generating. We expect noisy compounds to be removed and only the strongest evidence remains. We define a fitness \nfunction which evaluates the goodness of a solution $q$:\n\n$$ g(q) = -\\log{  \\sum_{i = 1}^{nc} q_i }  -  \\sum_{i \\in e_1, \\ldots, e_{ne}} p_i  $$\n\nWe maximize this function using a genetic algorithm via \\textbf{GA} R package. \nThe starting population contains the individual $q^{50}$ and also mutations $\\hat{q}$, where \neach bit $\\hat{q}_k$ had a $5\\%$ chance to negate his value.\nOnce the algorithm has finished we obtain $q_{final}$. Applying our original method \non it we obtain a whole subgraph, whose plot may explain the relationships \nbetween the affected enzymes and the predicted compounds.\n\n\n\n\\section{Report}\n\n\\subsection{Input}\n\nTable \\ref{tableInput} contains the items in the input.\n\n<<tableInput, results='asis', echo=FALSE>>=\nenz <- createUser()@diffusion@highlight\nif (length(enz) == 0) {\n  comp <- createUser()@input\n  tabInput <- data.frame(comp, createUser()@dictionary[comp])\n  names(tabInput) <- c(\"Compound\", \"Description\")\n  print(xtable(tabInput, \n               caption = \"Compounds in the input. These compounds are the heat source.\", \n               label = 'tableInput'), \n        include.rownames = FALSE, \n        caption.placement = getOption(\"xtable.caption.placement\", \"bottom\"), size = 'small')\n  \n} else {\n  tabInput <- data.frame(enz, createUser()@dictionary[enz])\n  names(tabInput) <- c(\"Enzyme\", \"Description\")\n  print(xtable(tabInput, caption = 'Enzymes in the input', label = 'tableInput'), include.rownames = FALSE, caption.placement = getOption(\"xtable.caption.placement\", \"bottom\"), size = 'small')\n  \n  comp <- createUser()@input\n  tabGuess <- data.frame(comp, createUser()@dictionary[comp])\n  names(tabGuess) <- c(\"Predicted compound\", \"Description\")\n  print(xtable(tabGuess, \n               caption = \"Compounds predicted from the input. These compounds are the \\\\textbf{new heat source}\", \n               label = 'tableGuess'), \n        include.rownames = FALSE, \n        caption.placement = getOption(\"xtable.caption.placement\", \"bottom\"), size = 'small')\n}\n\n@\n\n\n\\clearpage\n\n\\subsection{Relevant subgraph}\n\n% \\noindent\\makebox(\\strippt\\textwidth,1.6\\strippt\\textwidth){\n\\noindent\\makebox[\\textwidth]{\n\n<<plotGraph, fig.align=\"left\", results='hide', echo=FALSE, fig.width=12, fig.height=12, out.width=\"\\\\textwidth\">>=\nplot2(createUser(), type = \"diffusion\")\n@\n\n}\n\nAll the relevant nodes are plotted in the graph.\nPathways are red, modules are violet, enzymes are orange, reactions are blue and compounds are green. Generally nodes are circular. If compounds were specified, they appear as a green square. Otherwise, if enzymes were entered, both the \\textbf{enzymes at the input} and the \\textbf{predicted compounds} are squares.\n\nThe following table contains a brief description for each node and its p-value in the solution. Furthermore, in the case where the solution was built from significant enzymes, a \\textit{Guess} column highlights if a significant enzyme was already in the original input. \n\n\\subsection{Nodes in the relevant subgraph}\n\n\n\n\n\\resizebox{\\textwidth}{!}{\n<<tableGraphNodes, results='asis', echo=FALSE, resize.width=\"\\\\textwidth\", resize.height=\"\\\\textheight\">>=\n\n  tabRaw <- createSummary()$diffusion\n\n  if (dim(tabRaw)[1] <= 100) {\n    n.all <- dim(tabRaw)[1] + (dim(tabRaw)[1] %% 2)\n    n.half <- round(n.all/2)\n    tabOut <- cbind(tabRaw[1:n.half, ], tabRaw[(n.half + 1):n.all, ])\n    print(xtable(tabOut, \n               caption = \"Relevant nodes\", \n               label = 'tableGraphNodes'), \n        include.rownames = FALSE, \n        caption.placement = getOption(\"xtable.caption.placement\", \"bottom\"), \n        size = 'tiny',\n        floating=FALSE)\n  } else {\n    tabOut1 <- cbind(tabRaw[1:100, ], tabRaw[101:200, ])\n    print(xtable(tabOut1, \n           caption = \"Relevant nodes - 1 out of 2\", \n           label = 'tableGraphNodes1'), \n    include.rownames = FALSE, \n    caption.placement = getOption(\"xtable.caption.placement\", \"bottom\"), \n    size = 'tiny',\n    floating=FALSE)\n  }\n  \n\n@\n}\n\n\\resizebox{\\textwidth}{!}{\n<<tableGraphNodes2, results='asis', echo=FALSE, resize.width=\"\\\\textwidth\", resize.height=\"\\\\textheight\">>=\n\nif (dim(tabRaw)[1] > 100) {\n    tabRaw <- tabRaw[201:dim(tabRaw)[1], ]\n    n.all <- dim(tabRaw)[1] + (dim(tabRaw)[1] %% 2)\n    n.half <- round(n.all/2)\n    tabOut <- cbind(tabRaw[1:n.half, ], tabRaw[(n.half + 1):n.all, ])\n    print(xtable(tabOut, \n               caption = \"Relevant nodes - 2 out of 2\", \n               label = 'tableGraphNodes2'), \n        include.rownames = FALSE, \n        caption.placement = getOption(\"xtable.caption.placement\", \"bottom\"), \n        size = 'tiny',\n        floating=FALSE)\n}\n@\n}\n\n\\end{document}",
    "created" : 1431089147523.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1508757005",
    "id" : "3B4E85A4",
    "lastKnownWriteTime" : 1424711251,
    "path" : "~/Rstuffbro/SHELLA/report/sample.Rnw",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "sweave"
}