{
    "contents" : "runPagerank <- function(object = NULL, \n                        data = \"FELLA.DATA\", \n                        approx = \"simulation\", \n                        niter = 1000, \n                        p.adjust = \"fdr\") {\n  \n  # Checking the input\n  ##############################################################################\n  if (!is.FELLA.USER(object)) {\n    message(\"'object' is not a FELLA.USER object. Returning NULL...\")\n    return(invisible())\n  } \n  if (!is.FELLA.DATA(data)) {\n    message(\"'data' is not a FELLA.DATA object. Returning NULL...\")\n    return(invisible())\n  }\n  \n  if (data@keggdata@status != \"loaded\"){\n    message(\"'data' points to an empty FELLA.DATA object! Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (!is.character(approx)) {\n    message(\"'approx' must be a character: 'simulation' or 'normality'. Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (!(approx %in% c(\"simulation\", \"normality\"))) {\n    message(\"'approx' must be a character: 'simulation' or 'normality'. Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (!is.numeric(niter)) {\n    message(\"'niter' must be an integer between 100 and 1e5. Returning original 'object'...\")\n    return(object)\n  }\n  \n  if (niter < 100 | niter > 1e5) {\n    message(\"'niter' must be an integer between 100 and 1e5. Returning original 'object'...\")\n    return(object)\n  }\n  ##############################################################################\n  \n  message(\"Running PageRank...\")\n  \n  # Damping factor\n  d <- 0.7\n  \n  # The metabolites in the input\n  comp.input <- getInput(object)\n  n.input <- length(comp.input)\n  \n  if (n.input == 0) {\n    message(\"PageRank failed because there are no compounds in the input.\")\n    return(object)\n  }\n  \n  if (approx == \"simulation\") {\n    message(\"Estimating p-values by simulation.\")\n    \n    # The background\n    if (length(getBackground(object)) == 0) {\n      comp.background <- getCom(data, \"compound\")\n    } else {\n      comp.background <- getBackground(object)\n    }\n    \n    if (prod(dim(getMatrix(data, \"pagerank\"))) == 1) {\n      message(\"PageRank matrix not loaded. Simulations may be a bit slower...\")\n      \n      # Load the graph \n      graph <- getGraph(data)\n\n      # Prior for personalized PageRank\n      prior <- numeric(vcount(graph))\n      names(prior) <- V(graph)$name\n      \n      # Current scores\n      prior[comp.input] <- 1\n      current.score <- page.rank(graph = graph, \n                                 directed = T, \n                                 damping = d, \n                                 personalized = prior)$vector\n      prior[comp.input] <- 0\n      \n      # Null model\n      null.score <- sapply(1:niter, function(dummy) {\n        if (dummy %% round(.1*niter) == 0) message(round(dummy*100/niter),\"%\")\n        \n        prior[sample(comp.background, n.input)] <- 1\n        page.rank(graph = graph, \n                  directed = T, \n                  damping = d, \n                  personalized = prior)$vector\n      })\n      \n      n.nodes <- length(current.score)\n      pvalues <- sapply(1:n.nodes, function(row) {\n        ((1 - ecdf(null.score[row, ])(current.score[row]))*n.nodes + 1)/(n.nodes + 1)\n      })\n      names(pvalues) <- V(graph)$name\n      \n    } else {\n      # Calculate current scores.\n      # Warning: each score vector should be divided by n.input. It won't, as\n      # it just rescales all the scores and becomes irrelevant for the test.\n      pagerank.matrix <- getMatrix(data, \"pagerank\")\n      \n      if (n.input == 1) {\n        current.score <- pagerank.matrix[, comp.input]\n      }\n      else current.score <- rowSums(pagerank.matrix[, comp.input])\n      \n      null.score <- sapply(1:niter, function(dummy) {\n        if (dummy %% round(.1*niter) == 0) message(round(dummy*100/niter),\"%\")\n        \n        rowSums(pagerank.matrix[, sample(comp.background, n.input)])\n      })\n      \n      n.nodes <- length(current.score)\n      pvalues <- sapply(1:n.nodes, function(row) {\n        ((1 - ecdf(null.score[row, ])(current.score[row]))*n.nodes + 1)/(n.nodes + 1)\n      })\n      names(pvalues) <- rownames(pagerank.matrix)\n    }\n    \n  } else if (approx == \"normality\") {\n    message(\"Estimating p-values by normal tails.\")\n    \n    # The background\n    if (length(getBackground(object)) > 0) {\n      if (prod(dim(getMatrix(data, \"pagerank\"))) == 1) {\n        # Custom background, no matrix...\n        message(\"PageRank matrix not loaded. Normality is not available yet for custom background.\")\n        return(object)\n      } else {\n        # Custom background, matrix available\n        background.matrix <- getMatrix(data, \"pagerank\")[, getBackground(object)]\n        RowSums <- rowSums(background.matrix)\n        squaredRowSums <- apply(X = background.matrix, \n                                MARGIN = 1, \n                                FUN = function(row) sum(row*row))\n        \n        n.comp <- dim(background.matrix)[2]\n      }\n    } else {# Default background\n      n.comp <- length(getCom(data, \"compound\"))\n      \n      # RowSums\n      if (length(getSums(data, \"pagerank\", squared = F)) == 0) {\n        message(\"RowSums not available. The normal approximation cannot be done.\")\n        return(object)\n      } else {\n        RowSums <- getSums(data, \"pagerank\", squared = F)\n      }\n      \n      # Squared RowSums\n      if (length(getSums(data, \"pagerank\", squared = T)) == 0) {\n        message(\"squaredRowSums not available. The normal approximation cannot be done.\")\n        return(object)\n      } else {\n        squaredRowSums <- getSums(data, \"pagerank\", squared = T)\n      }\n    }\n    \n    # Compute current score\n    # Load the graph \n    graph <- getGraph(data)\n    \n    # Prior for personalized PageRank\n    prior <- numeric(vcount(graph))\n    names(prior) <- V(graph)$name\n    \n    # Current scores\n    prior[comp.input] <- 1\n    current.score <- page.rank(graph = graph, \n                               directed = T, \n                               damping = d, \n                               personalized = prior)$vector\n    \n    # p-values\n    score.means <- RowSums/n.comp\n    score.vars <- (n.comp - n.input)/(n.input*n.comp*(n.comp - 1))*(squaredRowSums \n                                                                   - (RowSums^2)/n.comp)\n    \n    pvalues <- pnorm(current.score, mean = score.means, \n                     sd = sqrt(score.vars), lower.tail = F)\n    names(pvalues) <- names(RowSums)\n    \n  } \n\n  pvalues <- p.adjust(p = pvalues, method = p.adjust)\n  \n  object@pagerank@pvalues <- pvalues\n  object@pagerank@approx <- approx\n  object@pagerank@niter <- niter  \n\n  message(\"Done.\")\n  object@pagerank@valid <- T\n  return(object)\n}",
    "created" : 1430899938626.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1683934853",
    "id" : "9143A3E6",
    "lastKnownWriteTime" : 1441621703,
    "path" : "~/Rstuffbro/FELLA/R/runPagerank.R",
    "project_path" : "R/runPagerank.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}