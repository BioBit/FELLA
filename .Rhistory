function(names) {
names[order(nchar(names))]
})
V(g.curated)$GENE <- m.enzyme_gene[V(g.curated)$name]
comment(g.curated) <- keggInfo(organism)
message("Done.")
if (GOterms) {
# GO terms
message("Adding GO terms to enzymes...")
# library(org.Hs.eg.db)
gene.all <- V(graph.curated)$GENE
gene2GO <- AnnotationDbi::as.list(org.Hs.eg.db::org.Hs.egGO)
V(g.curated)$GO <- plyr::llply(
V(g.curated)$GENE,
function(gene) {
if (!is.null(gene)) {
# browser()
tmp <- gene2GO[gene]
names(tmp) <- NULL
go_terms <- names(unlist(tmp, recursive = F))
if (!is.null(go_terms)) {
return(AnnotationDbi::Term(go_terms))
}
return(NA)
}
return(NA)
})
message("Done.")
}
keggdata.graph <- g.curated
GOterms <- T
if (GOterms) {
# GO terms
message("Adding GO terms to enzymes...")
# library(org.Hs.eg.db)
gene.all <- V(graph.curated)$GENE
gene2GO <- AnnotationDbi::as.list(org.Hs.eg.db::org.Hs.egGO)
V(g.curated)$GO <- plyr::llply(
V(g.curated)$GENE,
function(gene) {
if (!is.null(gene)) {
# browser()
tmp <- gene2GO[gene]
names(tmp) <- NULL
go_terms <- names(unlist(tmp, recursive = F))
if (!is.null(go_terms)) {
return(AnnotationDbi::Term(go_terms))
}
return(NA)
}
return(NA)
})
message("Done.")
}
buildGraphFromKEGG <- function(organism = "hsa",
GOterms = T) {
# library(KEGGREST)
# library(plyr)
# library(dplyr)
# library(igraph)
# organism <- "hsa"
categories <- c("pathway", "module", "enzyme", "reaction", "compound")
# Get rid of hsa:, cpd:....
sanitise <- function(x, category, organism) {
old.attr <- attributes(x)
if (category == "pathway") {
ans <- gsub("(path:)(.+)(\\d{5})", paste0(organism, "\\3"), x)
}
if (category == "module") {
ans <- gsub("(md:)(.*)(M\\d{5})", "\\3", x)
}
if (category == "enzyme") {
ans <- ifelse(grepl(pattern = "-", x = x),
NA,
gsub("(ec:)(\\d+\\.\\d+\\.\\d+\\.\\d+)", "\\2", x))
}
if (category == "gene") {
ans <- gsub(paste0("(", organism, ":)(\\d+)"), "\\2", x)
}
if (category == "reaction") {
ans <- gsub("(rn:)(R\\d{5})", "\\2", x)
}
if (category == "compound") {
ans <- gsub("(cpd:)(C\\d{5})", "\\2", x)
}
attributes(ans) <- old.attr
ans
}
# Connections through genes
infere.con2ec <- function(ids, ent, ent2gene, gene2enzyme) {
ans <- plyr::ldply(
ids,
function(x) {
aux <- ent2gene[names(ent2gene) == x]
ans <- unique(gene2enzyme[names(gene2enzyme) %in% aux])
# names(ans) <- rep(x, length(ans))
data.frame(from = ans, to = rep(x, length(ans)))
})
attr(ans, "from") <- "enzyme"
attr(ans, "to") <- ent
ans
}
# Data from KEGGREST
#
# List of id-name
message("Building through KEGGREST...")
list.list <- plyr::llply(
setNames(categories, categories),
function(category) {
if (category %in% c("pathway", "module")) {
ans <- KEGGREST::keggList(
database = category,
organism = organism)
} else {
ans <- KEGGREST::keggList(database = category)
}
names(ans) <- sanitise(names(ans), category, organism)
ans
},
.progress = "text"
)
# Map identifiers to category
map.category <- plyr::ldply(
list.list,
function(categ)
data.frame(id = names(categ),
stringsAsFactors = F),
.id = "category")
map.category <- setNames(as.character(map.category$category),
map.category$id)
# List of kegg links - essentially our edges
list.link <- plyr::alply(
expand.grid(categories,
categories,
KEEP.OUT.ATTRS = F,
stringsAsFactors = F)[lower.tri(matrix(1:25, nrow = 5)), ],
1,
function(row) {
# browser()
original <- KEGGREST::keggLink(row[1], row[2])
df <- data.frame(from = sanitise(original, row[1], organism),
to = sanitise(names(original), row[2], organism))
attr(df, "from") <- as.character(row[1])
attr(df, "to") <- as.character(row[2])
df
},
.progress = "text"
)
attributes(list.link) <- NULL
# To mine mapping through enzymes
m.path_gene <- KEGGREST::keggLink(organism, "pathway") %>%
setNames(., sanitise(names(.), "pathway", organism))
m.mod_gene <- KEGGREST::keggLink(organism, "module") %>%
setNames(., sanitise(names(.), "module", organism))
m.gene_enzyme <- KEGGREST::keggLink("enzyme", organism) %>%
sanitise(., "enzyme", organism)
m.enzyme_gene <- KEGGREST::keggLink(organism, "enzyme") %>%
setNames(., sanitise(names(.), "enzyme", organism)) %>%
sanitise(., "gene", organism) %>%
split(., names(.), drop = T) %>%
plyr::llply(., function(r) sort(as.character(r)))
# Inferred connections (through genes)
con.infere <- list(
infere.con2ec(names(list.list$pathway),
"pathway",
m.path_gene,
m.gene_enzyme),
infere.con2ec(names(list.list$module),
"module",
m.mod_gene,
m.gene_enzyme)
)
# Direct connections
df.noinfere <- plyr::ldply(
list.link,
function(df.piece) {
a.from <- attr(df.piece, "from")
a.to <- attr(df.piece, "to")
if (a.from == "enzyme" & (a.to %in% c("module", "pathway")))
return(NULL)
# browser()
return(df.piece)
},
.id = NULL
)
df.infere <- plyr::ldply(
con.infere,
function(df.piece) {
a.from <- attr(df.piece, "from")
a.to <- attr(df.piece, "to")
return(df.piece)
}
)
matrix.adjacency <- as.matrix(rbind(
df.noinfere,
df.infere
))
message("Done.")
message("Building graph...")
g.raw <- graph.edgelist(matrix.adjacency, directed = T) %>%
simplify
V(g.raw)$com <- match(map.category[V(g.raw)$name], categories)
# Nodes without a kegg name are either obsolete or inexistent
g.raw <- delete.vertices(
g.raw,
which(is.na(V(g.raw)$com)))
# Enzymes that cannot be inferred should be deleted
# (not found in desired species!)
g.raw <- delete.vertices(
g.raw,
which((V(g.raw)$com == 3) & !(V(g.raw)$name %in% df.infere$from)))
# Order by category and id
g.raw <- permute.vertices(g.raw,
order(order(V(g.raw)$com, V(g.raw)$name)))
g.edges <- get.edges(g.directed, E(g.directed))
# Weighting the edges
tmp <- get.edges(g.raw, E(g.raw))
E(g.raw)$weight <- abs(V(g.raw)$com[tmp[, 1]] - V(g.raw)$com[tmp[, 2]])
# Keep only reactions in a pathway
# i.e. delete reactions that don't have any 3-weight edge
g.raw <- (setdiff(
which(V(g.raw)$com == 4),
get.edges(g.raw, E(g.raw)[weight == 3])[, 1]) %>%
delete.vertices(graph = g.raw, .))
# Keep only compounds that are reactants/products in these reactions
# i.e. delete compounds that don't have any 1-weight edge
g.raw <- (setdiff(
which(V(g.raw)$com == 5),
get.edges(g.raw, E(g.raw)[weight == 1])[, 1]) %>%
delete.vertices(graph = g.raw, .))
# Other filtering (remove nodes?)
largestcc <- function(graph) {
cl <- clusters(graph)
x <- which.max(cl$csize)
induced.subgraph(graph, which(cl$membership == x))
}
g.raw <- largestcc(g.raw)
message("Done.")
message("Pruning graph...")
# CURATE GRAPH
# We start with the graph curation
edges.split <- split(1:ecount(g.raw), E(g.raw)$weight)
message(paste0("Current weight: 1 out of 4..."))
g.curated <- subgraph.edges(
graph = g.raw,
eids = edges.split[[1]],
delete.vertices = F)
for (w in names(edges.split)[-1]) {
current.w <- as.numeric(w)
message(paste0("Current weight: ", w, " out of 4..."))
# browser()
dist.matrix <- distances(g.curated, mode = "out")
list.edges <- edges.split[[w]]
list.ends <- ends(g.raw, list.edges)
new.edges <- dist.matrix[list.ends] > E(g.raw)$weight[list.edges]
g.curated <- add.edges(
graph = g.curated,
edges = t(list.ends[new.edges, ]),
attr = list(weight = E(g.raw)[list.edges[new.edges]]$weight))
}
# Final edge weights have to be inverted
E(g.curated)$weight <- 1/E(g.curated)$weight
tmp <- list.list
names(tmp) <- NULL
tmp <- unlist(tmp)
V(g.curated)$NAME <- lapply(
strsplit(tmp[V(g.curated)$name], split = "; "),
function(names) {
names[order(nchar(names))]
})
V(g.curated)$GENE <- m.enzyme_gene[V(g.curated)$name]
comment(g.curated) <- keggInfo(organism)
message("Done.")
if (GOterms) {
# GO terms
message("Adding GO terms to enzymes...")
# library(org.Hs.eg.db)
gene.all <- V(graph.curated)$GENE
gene2GO <- AnnotationDbi::as.list(org.Hs.eg.db::org.Hs.egGO)
V(g.curated)$GO <- plyr::llply(
V(g.curated)$GENE,
function(gene) {
if (!is.null(gene)) {
# browser()
tmp <- gene2GO[gene]
names(tmp) <- NULL
go_terms <- names(unlist(tmp, recursive = F))
if (!is.null(go_terms)) {
return(AnnotationDbi::Term(go_terms))
}
return(NA)
}
return(NA)
})
message("Done.")
}
keggdata.graph <- g.curated
return(keggdata.graph)
}
g <- buildGraphFromKEGG()
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
g <- buildGraphFromKEGG()
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
g <- buildGraphFromKEGG()
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
g <- buildGraphFromKEGG()
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
g <- buildGraphFromKEGG()
g
g1
g2
setdiff(V(g), V(g2))
setdiff(V(g2), V(g))
V(g2)[9618]
neighbors(g2, 9618)
comment(g2)
comment(g)
setdiff(E(g2), E(g))
setdiff(E(g), E(g2))
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
g <- buildGraphFromKEGG()
library(igraph)
library(plyr)
library(dplyr)
g <- buildGraphFromKEGG()
g <- buildGraphFromKEGG()
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
g <- buildGraphFromKEGG()
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
g <- buildGraphFromKEGG()
g
head(V(g)$GO)
head(V(g)[com==3]$GO,2)
load("/home/sergi/all/devel/big/metabolomics/FELLAdataKEGGREST/keggdata.graph.RData")
sum(get.adjacency(g) != get.adjacency(keggdata.graph))
g
keggdata.graph
gg <- keggdata.graph
setdiff(V(gg),V(g))
setdiff(E(gg),E(g))
paste(matrix(c(1,2,3,4),ncol=2))
apply(matrix(c(1,2,3,4),ncol=2),1,paste)
apply(matrix(c(1,2,3,4),ncol=2),1,paste0)
apply(matrix(c(1,2,3,4),ncol=2),1,function(x) paste(x, collapse=""))
fag <- function(g) apply(get.edges(g, E(g)),1,function(x) paste(x, collapse=""))
setdiff(fag(gg),fag(g))
get.edges(g,1)
get.edgelist(g)
fag <- function(g) apply(get.edgelist(g),1,function(x) paste(x, collapse=""))
setdiff(fag(gg),fag(g))
setdiff(fag(g),fag(gg))
fag <- function(g) apply(get.edgelist(g),1,function(x) paste(x, collapse="_"))
setdiff(fag(gg),fag(g))
setdiff(fag(g),fag(gg))
comment(g)
comment(gg)
gmmu <- buildGraphFromKEGG(organism = "mmu")
gmmu
g
head(V(gmmu)[com==3]$GO)
head(V(gmmu)[com==3]$GENE)
library(GO.db)
a<-columns(GO.db)
dim(a)
a
ls("package:GO.db")
GOTERM
x<-as.list(GOTERM)
head(x)
ls("package:GO.db")
x<-as.list(GO)
head(x)
x<-as.list(GO.db)
head(x)
x<-as.list(geneSim())
ls("package:GO.db")
x<-as.list(GO_dbconn())
x<-as.list(GO_dbconn
)
x
gmmu
head(V(gmmu)[com==3]$GENE)
gmmu
g
setdiff(V(g)$name, V(gmmu)$name)
setdiff(V(gmmu)$name, V(g)$name)
gpfh <- buildGraphFromKEGG("pfh")
gpfh
gsenc <- buildGraphFromKEGG("senc")
gsenc
grrs <- buildGraphFromKEGG("rrs")
is.connected(grrs)
(grrs)
is.simple(grrs)
head(V(grrs)[com==3]$GENE)
head(V(gpfh)[com==3]$GENE)
head(V(gpfh)[com==3]$NAMEA)
head(V(gpfh)[com==3]$NAME)
head(V(gpfh)[com==3]$GO)
source('~/all/devel/rpackages/FELLA/data-raw/generateGraphFromKEGGREST.R', echo=TRUE)
grrs <- buildGraphFromKEGG("rrs")
head(V(grrs)[com==3]$NAME)
head(V(grrs)[com==3]$GENE)
ghsa <- buildGraphFromKEGG("hsa")
head(V(ghsa)[com==3]$NAME)
head(V(ghsa)[com==3]$GENE)
head(V(ghsa)[com==3]$GO)
comment(ghsa)
g <- barabasi.game(100)
plot(g)
layout_nicely
layout_with_dh()
layout_with_fr
plot(g, layout = "fruchterman")
plot(g, layout = "fruchterman_reingold")
plot(g, layout = "layout_fruchterman_reingold")
plot(g, layout = "layout_with_fr")
plot(g, layout = layout_with_fr)
plot(g, layout = layout_with_fr)
plot(g, layout = layout_with_fr)
g <- barabasi.game(300)
plot(g, layout = layout_with_fr)
plot(g, layout = layout_with_dr)
plot(g, layout = layout_with_drl)
layout_with_fr(g)
install(dependencies = F)
document()
document()
warnings()
document()
install(dependencies = F)
warnings()
install(dependencies = F)
ghsa
"hsa01100" %in% V(gsha)$ma,e
"hsa01100" %in% V(gsha)$name
V(gsha)["hsa01100"]$name
V(gsha)["hsa01100"]
ghsa
V(gsha)["hsa01100"]
V(ghsa)["hsa01100"]
grepl("hi",x = c("a","bhi"))
grepl(c("hi", "a"),x = c("a","bhi"))
?grepl
source('~/all/devel/rpackages/FELLA/R/buildGraphFromKEGGREST.R', echo=TRUE)
ghsa <- buildGraphFromKEGG("hsa")
ghsa2 <- buildGraphFromKEGGREST("hsa", filter.path = "01100")
ghsa2
ghsaç
ghsa
document()
document()
install(dependencies = F)
library(FELLA)
g <- buildGraphFromKEGGREST(filter.path = "01100")
is.connected(g)
igraph::is.connected(g)
buildDataFromGraph(g, "~/all/devel/big/metabolomics/FELLAdataKEGGREST_no01100")
buildDataFromGraph(g, "~/all/devel/big/metabolomics/FELLAdataKEGGREST_no01100", niter = 11)
install.packages("RANKS")
library(bionetdata)
install.packages("bionetdata")
browseVignettes(RANKS)
browseVignettes("RANKS")
load("/home/sergi/all/devel/projects/bioinfo/003_diffusion_graphs/code/ranks/paper/data/MESH_5_200.rda")
load("/home/sergi/all/devel/projects/bioinfo/003_diffusion_graphs/code/ranks/paper/data/finet.rda")
devtools::document()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
devtools::check_doc()
?FELLA.USER
dput(summary)
dput(show)
devtools::check_doc()
sessionInfo()
install.packages("roxygen2")
install.packages("roxygen2")
devtools::check_doc()
?FELLA::show
devtools::check_doc()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
.Call
?.Call
devtools::check()
devtools::check()
warnings()
warnings()
devtools::check()
test()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check_cran()
devtools::check_cran("FELLA")
devtools::check_doc()
devtools::check_failures()
